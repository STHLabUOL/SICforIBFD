% Orthogonal frequency-division multiplex (OFDM) signal generation for
% a Wiener (W) system option by using WLAN-Toolbox. The W-system consists
% of a self-inference (SI) channel with impulse response (IR) h_SI[k]
% and an additive white Gaussian noise (AWGN) followed by a nonlinear (NL)
% low-noise amplifier (LNA), leading to the following signal model, see
% Fig. 1b) in [1]:
% z -> [IR] -> x -> [AWGN] -> yH -> [NL-LNA] -> yW and z -> [ATT] -> za
% 
% The generated signals are stored together with the configuration
% parameters in .mat files. Each .mat file consists of a single OFDM packet
% (which changes from file to file) and is generated by using a time-
% invariant IR (which does not change within a file). Data is generated
% and stored for both training and test data sets.
% 
% With this script, 4 datasets with different system dynamics can be
% generated. Every dataset is configured by setting of 2 binary parameters
% that describe a specific use of IR and NL, respectively.
% For IR configuration, 2 possibilities are available:
%   (a) with the same time-invariant IR used in all .mat files (invSI)
%   (b) with the time-invariant IRs indivudual for every .mat file (varSI)
% IRs of the SI channel is adjusted acc. to [2]. And also NL can be
% simulated in 2 different ways:
%   (a) with the same NL used in all .mat files (invNL)
%   (b) with the NL indivudual for every .mat file (varNL)
% NOTE: This impmenetation is valid for limiter NL.
% 
% [1] G. Enzner, A. Chinaev, S. Voit, A. Sezgin, 'On Neural-Network
% Representation of Wireless Self-Interference for Inband Full-Duplex
% Communications', submitted to IEEE ICASSP-2025.
% [2] F. Chen, R. Morawski, T. Le-Ngoc, 'Self-interference channel
% characterization for wideband 2x2 MIMO full-duplex transceivers using
% dual-polarized antennas', IEEE Trans. Antennas and Propagation, 2018.
% 
% AC, 2024.08.28

%% 
addpath('functions');
clear variables; clc; close all
strings.datetime_start = string(datetime('now')); fprintf(strings.datetime_start); fprintf('\n');

%% Some simalation variables
NumFiles = 50;          % number of files per dataset
flags.save_mat = 0;     % flag for saving the .mat-files (0 not save, 1 save)
flags.plot_fig = 1;     % flag for visualization of the control variables

%% Configuration of a dataset regarding IR and NL usage
flags.varSI = 1;        % 0 - 'invSI', 1 (or otherwise) - 'varSI'
flags.varNL = 1;        % 0 - 'invNL', 1 (or otherwise) - 'varNL'

if flags.varSI==0; strings.SI = 'invSI'; else; strings.SI = 'varSI'; end
if flags.varNL==0; strings.NL = 'invNL'; else; strings.NL = 'varNL'; end
datasets_str = {'train', 'test'};
% check and make folders for datasets, if not available
folders.data = 'Data';
folders.dataset = [strings.SI '_' strings.NL];
folders.datasets_str = datasets_str;
if flags.save_mat; utils.checkMakeFolders(folders); end

%% Configuration of signal generation
% Create a format configuration object for a HT (High Throughput, HT) transmission
cfgHT = utils.createCfgHT();
% Create and configure the HT task group (TG) n-channel
tgnChannel = utils.createTGnChannel(cfgHT);
% display some parameters of cfgHT and tgnChannel
disp(['802.11n ' cfgHT.ChannelBandwidth ' MCS' num2str(cfgHT.MCS) ' ' cfgHT.SpatialMapping '-Map ' ...
    num2str(cfgHT.NumTransmitAntennas) 'Tx*' num2str(tgnChannel.NumReceiveAntennas) 'Rx Mod-SI-Chan-' ...
    tgnChannel.DelayProfile ' ' cfgHT.ChannelCoding ' ' num2str(tgnChannel.TransmitReceiveDistance) 'm']);
% Get tgnChanel infos and some variables for generation of OFDM signals
[tgnChan_info, parSigs] = utils.getTGnInfosParams(cfgHT, tgnChannel);
% Parameters of SI channel, attenuator, AWGN and LNA
[parChanSI, parAtt, parSigs, parAmpIn] = configSystemOption.W(flags, parSigs);

%% Generation of train and test data
for idx_datasets=1:length(datasets_str)
    disp([datasets_str{idx_datasets} ' dataset:']);

    % Initialize visualizer of signal properties
    visualizer = VisualizerW(NumFiles);
    
    %% Perform the signal generation
    idx_sim = 0; idx_file = 0;
    while 1
        % set random substream index per generated file to ensure that each
        % iteration uses a repeatable set of random numbers (if required)
        stream = RandStream('combRecursive','Seed',3+2*idx_sim+idx_datasets); % ~mean for TxRxDist = 0.7e-2
        RandStream.setGlobalStream(stream);
        
        %% Generate a packet-based waveform
        tx_PSDU = randi([0 1], cfgHT.PSDULength*8,1);  % generate random PSDU bits
        tx_WG = wlanWaveformGenerator(tx_PSDU, cfgHT); % generate respective WLAN waveform
        % Add trailing zeros to allow for channel filter delay
        sig_z = [tx_WG; zeros(parSigs.NumTrailingZeros, cfgHT.NumTransmitAntennas)];

        %% Apply attenuator
        sig_za = parAtt.factor_PowAttGain*sig_z; % pow(x) = 2*factor_PA^2

        %% Apply SI channel
        % reset the channel parameters (new pathGains), if required
        if flags.varSI~=0; reset(tgnChannel); end
        [sig_x, tgnChan_info, parChanSI] = SIchannel.adjustApply(sig_z, tgnChannel, parChanSI);
        % Obtain statistics of the SI channel
        parChanSI = SIchannel.statsChanSI(parChanSI, tgnChan_info.PathDelays);

        %% AWGN (for both train and test data)
        [sig_yH, pow_AWGNonChanSI] = awgn(sig_x, parSigs.SINR_dB_awgn, 'measured');
    
        %% Apply nonlinear low-noise amplifier
        parAmpIn.SISDR_dB = parAmpIn.SISDR_dB_desired + parAmpIn.SISDR_dB_desiredDelta*(2*rand(1)-1);
        parLowNoiAmpl.parAmpIn = parAmpIn;
        [sig_yW, parLowNoiAmpl] = Nonlinearity.applyAmplifier(sig_yH, parLowNoiAmpl);

        % if parLowNoiAmpl.parAmpOut.SISDR_OutIn_dB < 1.1*SISDR_dB_desired
        if abs(parLowNoiAmpl.parAmpOut.SISDR_OutIn_dB-parAmpIn.SISDR_dB_desired) < parAmpIn.SISDR_dB_desiredDelta % SISDR_dB_desired \pm 5dB
        % if SISDR_dB_desired-7<parLowNoiAmpl.parAmpOut.SISDR_OutIn_dB && parLowNoiAmpl.parAmpOut.SISDR_OutIn_dB<SISDR_dB_desired+10 % SISDR_dB_desired \pm 5dB
            fprintf(['Generated suitable OFDM signals for idx_file = ' num2str(idx_file) '...']);
    
            % calculate statistics of the generated signals
            parSigs.pow_z_dB = 10*log10(mean(power(abs(sig_z),2)));
            parSigs.pow_za_dB = 10*log10(mean(power(abs(sig_za),2)));
            parSigs.pow_x_dB = 10*log10(mean(power(abs(sig_x),2)));
            parSigs.pow_yH_dB = 10*log10(mean(power(abs(sig_yH),2)));
            parSigs.pow_yW_dB = 10*log10(mean(power(abs(sig_yW),2)));
            parSigs.pow_AWGNonChanSI_dB = 10*log10(pow_AWGNonChanSI);
            
            %% save signals and parameters in a specific file if required
            if flags.save_mat
                fprintf(' Save generated signals in a .mat file.');
                filename = ['fileID' num2str(idx_file) '.mat'];
                save([folders.data '/' folders.dataset '/' datasets_str{idx_datasets} '/' filename], ...
                    'sig_z', 'sig_za', 'sig_x', 'sig_yH', 'sig_yW', 'cfgHT', 'tgnChannel', ...
                    'tgnChan_info', 'parLowNoiAmpl', 'parSigs', 'parChanSI', 'parAtt');
            end; fprintf('\n');
            
            %% Prepare control variables for visualization
            visualizer = visualizer.fill(idx_file, parSigs, parLowNoiAmpl, parChanSI);
            
            idx_file = idx_file+1;
            if idx_file==NumFiles
                break;
            end
        end
        idx_sim = idx_sim+1;
    end
    
    %% Visualization of the control variables (if required)
    if flags.plot_fig
        h_fig = visualizer.plot(datasets_str, idx_datasets, folders, parAmpIn, parSigs);
        % saveas(h_fig, [folders.data '/' folders.dataset '/' datasets_str{idx_datasets}], 'jpeg');
    end
end
strings.datetime_start = string(datetime('now')); fprintf(strings.datetime_start); fprintf('\n');